/**
*******************************************************************************
* @file           : dictionary.c
* @brief          :
* @author         :
* @date           : 18/01/2023
*******************************************************************************
* @attention
*
* Copyright (c) 18/01/2023 Abelardo Cuffia S.A. All rights reserved.
*
*/
/******************************************************************************
    Includes
******************************************************************************/
#include "dictionary.h"
#include "delay.h"
#include "can_tables.h"
#include "can_tables_base.h"

/******************************************************************************
    Defines and constants
******************************************************************************/

/******************************************************************************
    Data types
******************************************************************************/
typedef struct
{
    int32_t value;
    delay_t expiration;
    uint16_t status;
} dictionary_element_t;

/******************************************************************************
    Local variables
******************************************************************************/
static dictionary_element_t dictionary[MAX_CAN_SIGNALS] = {0};

/******************************************************************************
    Local function prototypes
******************************************************************************/
/**
 * @brief Function to check if signal is valid according to its expiration time.
 * This time is ignored if the signal is generated by the node itself.
 *
 * @param uint16_t index: signal index.
 *
 * @return true if signal is valid, otherwise false.
 */
static bool is_valid_signal(uint16_t index);

/******************************************************************************
    Local function definitions
******************************************************************************/
static bool is_valid_signal(uint16_t index)
{
    bool ret_val = false;

    if ((DELAY_RUNNING == delay_get_status(&dictionary[index].expiration)
            || (0 == can_signal_st[index].duration))
            || (true == can_signal_st[index].source))
    {
        ret_val = true;
    }

    return ret_val;
}

/******************************************************************************
    Public function definitions
******************************************************************************/

dictionary_ret_t dictionary_init(void)
{
    for (uint16_t i = 0; i < MAX_CAN_SIGNALS; i++)
    {
        dictionary[i].value = can_signal_st[i].default_value;

        delay_init(&dictionary[i].expiration, can_signal_st[i].duration);
    }

    return DICTIONARY_OK;
}

dictionary_ret_t dictionary_read(uint16_t index, int32_t *value, uint16_t *status)
{
    return dictionary_read_int(index, value, status);
}

dictionary_ret_t dictionary_read_int(uint16_t index, int32_t *value, uint16_t *status)
{
    dictionary_ret_t ret_val = DICTIONARY_ERROR;

    if (true == is_valid_signal_index(index))
    {
        if (true == is_valid_signal(index))         //TODO: Check this approach
        {
            *value = dictionary[index].value;
        }
        else
        {
            *value = can_signal_st[index].default_value;
        }

        *status = dictionary[index].status;
        ret_val = DICTIONARY_OK;
    }

    return ret_val;
}

dictionary_ret_t dictionary_read_float(uint16_t index, float *value, uint16_t *status)
{
    dictionary_ret_t ret_val = DICTIONARY_ERROR;

    if (true == is_valid_signal_index(index))
    {
        if (true == is_valid_signal(index))         //TODO: Check this approach
        {
            *value = ((float)dictionary[index].value) / ((float)can_signal_st[index].precision);
        }
        else
        {
            *value = ((float)can_signal_st[index].default_value) / ((float)can_signal_st[index].precision);
        }

        *status = dictionary[index].status;
        ret_val = DICTIONARY_OK;
    }

    return ret_val;
}

dictionary_ret_t dictionary_write(uint16_t index, int32_t value, uint16_t *status)
{
    return dictionary_write_int(index, value, status);
}

dictionary_ret_t dictionary_write_int(uint16_t index, int32_t value, uint16_t *status)
{
    dictionary_ret_t ret_val = DICTIONARY_ERROR;

    if (true == is_valid_signal_index(index))
    {
        dictionary[index].value = value;
        delay_reset(&dictionary[index].expiration);
        *status = dictionary[index].status;
        ret_val = DICTIONARY_OK;
    }

    return ret_val;
}

dictionary_ret_t dictionary_write_float(uint16_t index, float value, uint16_t *status)
{
    dictionary_ret_t ret_val = DICTIONARY_ERROR;

    if (true == is_valid_signal_index(index))
    {
        dictionary[index].value = (int32_t)(value * can_signal_st[index].precision);
        delay_reset(&dictionary[index].expiration);
        *status = dictionary[index].status;
        ret_val = DICTIONARY_OK;
    }

    return ret_val;
}
